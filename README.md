## Объектно-ориентированное программирование

В различных источниках выделяют разное количество ООП-парадигм, но зачастую выделяют именно шесть:  
1. Инкапсуляция
2. Полиморфизм
3. Наследование
4. Абстракция
5. Посылка сообщений
6. Повторное использование

Рассмотрим каждую парадигму подробнее:  
### Инкапсуляция

Существует две трактовки инкапсуляции.   
Первую определяют следующим образом: инкапсуляция - это объединение данных или функций, которые управляют 
данными в один единый компонент.   
Вторая трактовка: инкапсуляция - это возможности языка программирования ограничить доступ одних компонентов 
программы к другим

Рассмотрим следующий пример:
```C#
class Name
{
    private string name = "Anton"; // Данные
    
    public void ShowName() // Метод для управления данными
    {
        Console.WriteLine(this.name);
    }
}
```
Данный блок кода одновременно подходит под две трактовки, поэтому нельзя говорить о том, что одна из них 
неправильная. Стоит отметить, что трактовки друг другу не противоречат, а скорее подтверждают друг друга

```
Герберт Шилдт "Java: руководство для начинающих"

Инкапсуляция представляет собой механизм программирования, объединяющий код и данные, которыми он
манипулирует. Он предотвращает несанкционированный доступ к данным извне и их некорректное использование. 
В объектно-ориентированных языках программирования код и данные организуются в некое подобие 
“черного ящика”. В результате такого объединения кода и данных создается объект. Иными словами, 
объект — это компонент, поддерживающий инкапсуляцию.
```
При этом важно разделять понятия инкапсуляции и сокрытия. Например, в Python существует инкапсуляция, но
отсутствует сокрытие. В Python сокрытие является лишь конвенцией, соглашением
Вот, что об этом в своей книге писал Марк Лутц:
```
Марк Лутц "Изучаем Python"

В языке Python сокрытие данных в модулях является соглашением, а не синтаксическим ограничением. 
Если вы хотите нарушить работу модуля, уничтожив его имена, то вполне можете поступить так, но к счастью 
мне не приходилось встречать программиста, для которого это было бы жизненно важной целью. 
Некоторые сторонники пуризма возражают против такого свободного отношения к сокрытию данных, заявляя
о том, что подобное положение вещей означает отсутствие возможности реализовать инкапсуляцию в Python. 
Тем не менее, инкапсуляция в Python больше связана с организацией пакетов, чем с установлением ограничений.
```
**То есть инкапсуляция обеспечивает сокрытие (во многих объектно-ориентированных языках программирования), но 
не является сокрытием**

Пример сокрытия в Python:  
Как было описано ранее, в Python существует соглашение по сокрытию. Одиночное подчеркивание в начале имени 
атрибута говорит о том, что переменная или метод не предназначен для использования вне методов класса, 
однако атрибут доступен по этому имени.

```Python
>>> class A:
...    def _private(self):
...        print("Это приватный метод!")
...        
>>> a = A()
>>> a._private()
Это приватный метод!
```
Двойное подчеркивание в начале имени атрибута даёт большую защиту: атрибут становится недоступным по 
этому имени.
```Python
>>> class B:
...     def __private(self):
...         print("Это приватный метод!")
...
>>> b = B()
>>> b.__private()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'B' object has no attribute '__private'
```
Однако полностью это не защищает, так как атрибут всё равно остаётся доступным под именем 
экземплярКласса._ИмяКласса__ИмяАтрибута:
```Python
>>> b._B__private()
Это приватный метод!
```
Все, что было указано выше называют уровнями доступа к данным:
1. Публичный (без подчеркиваний)
2. Защищенный (с одним подчеркиванием)
3. Приватный (с двумя подчеркиваниями)

### Наследование
Наследование - это механизм языка программирования, который позволяет описывать новый класс на основе 
существующего.
```Python
>>> class A:
...     def show_message(self):
...         print('message')
... 
>>> class B(A):
...     pass
... 
>>> b = B()
>>> b.show_message()
message
```

Сам процесс наследования в Python происходит следующим образом:
```
Марк Лутц "Изучаем Python"
Формально наследование вводит в действие две разных, но похожих процедуры поиска, и основано на MRO 
(Method Resolution Order — порядок распознавания методов).
Поскольку __bases__ применяется для создания упорядочения __mro__ во время создания классов, а __mro__ класса 
включает самого себя, обобщение из предыдущего раздела будет таким же, как приведенное далее начальное 
определение алгоритма наследования нового стиля Python.

Для поиска явного имени атрибута выполнить описанные ниже шаги.
1. Начиная с экземпляра I, провести поиск в экземпляре, затем в его классе и далее
во всех суперклассах класса, используя:
а) словарь __diсt__ экземпляра I;
б) словари __diсt__ всех классов в __mro__ , найденном в __class__ экземпляра I, слева направо.
2. Начиная с класса С, провести поиск в классе, затем во всех его суперклассах и
далее в его дереве метаклассов, используя:
а) словари __diсt__ всех классов в __mro__ , найденном в самом классе С, слева направо;
б) словари __diсt__ всех метаклассов в __mro__ , найденном в __class__ класса С, слева направо.
3. В шагах 1 и 2 предоставить приоритет дескрипторам данных, которые найдены в источниках в пункте б) 
(см. далее).
4. Для встроенных имен в шагах 1 и 2 пропустить пункт а) и начать поиск с пункта б) (см. далее).
Первые два шага выполняются только для обычного явного извлечения атрибутов.
Предусмотрены исключения для встроенных имен и дескрипторов, которые вскоре будут
прояснены. Вдобавок, как объяснялось в главе 38, для отсутствующих или всех имен
может также применяться метод__ getattr__ или___getattribute__ .
Большинству программистов нужно знать лишь первое из этих правил и возможно
первый шаг второго, которые вместе соответствуют наследованию кла£сических классов
Python 2.Х. Для метаклассов добавлен дополнительный шаг (26), но по существу он такой же, как остальные — безусловно, довольно тонкая равнозначность, но метаклассы
не настолько новы, как может показаться. Фактически они — всего лишь один компонент более крупной модели.
```













`git clone https://github.com/dellream/REST-API-app_test_task.git`

```
docker-compose up -d
```