## Объектно-ориентированное программирование

В различных источниках выделяют разное количество ООП-парадигм, но зачастую выделяют именно шесть:  
1. Инкапсуляция
2. Полиморфизм
3. Наследование
4. Абстракция
5. Посылка сообщений
6. Повторное использование

Рассмотрим каждую парадигму подробнее:  
### Инкапсуляция

Существует две трактовки инкапсуляции.   
Первую определяют следующим образом: инкапсуляция - это объединение данных или функций, которые управляют 
данными в один единый компонент.   
Вторая трактовка: инкапсуляция - это возможности языка программирования ограничить доступ одних компонентов 
программы к другим

Рассмотрим следующий пример:
```C#
class Name
{
    private string name = "Anton"; // Данные
    
    public void ShowName() // Метод для управления данными
    {
        Console.WriteLine(this.name);
    }
}
```
Данный блок кода одновременно подходит под две трактовки, поэтому нельзя говорить о том, что одна из них 
неправильная. Стоит отметить, что трактовки друг другу не противоречат, а скорее подтверждают друг друга

```
Герберт Шилдт "Java: руководство для начинающих"

Инкапсуляция представляет собой механизм программирования, объединяющий код и данные, которыми он
манипулирует. Он предотвращает несанкционированный доступ к данным извне и их некорректное использование. 
В объектно-ориентированных языках программирования код и данные организуются в некое подобие 
“черного ящика”. В результате такого объединения кода и данных создается объект. Иными словами, 
объект — это компонент, поддерживающий инкапсуляцию.
```
При этом важно разделять понятия инкапсуляции и сокрытия. Например, в Python существует инкапсуляция, но
отсутствует сокрытие. В Python сокрытие является лишь конвенцией, соглашением
Вот, что об этом в своей книге писал Марк Лутц:
```
Марк Лутц "Изучаем Python"

В языке Python сокрытие данных в модулях является соглашением, а не синтаксическим ограничением. 
Если вы хотите нарушить работу модуля, уничтожив его имена, то вполне можете поступить так, но к счастью 
мне не приходилось встречать программиста, для которого это было бы жизненно важной целью. 
Некоторые сторонники пуризма возражают против такого свободного отношения к сокрытию данных, заявляя
о том, что подобное положение вещей означает отсутствие возможности реализовать инкапсуляцию в Python. 
Тем не менее, инкапсуляция в Python больше связана с организацией пакетов, чем с установлением ограничений.
```
**То есть инкапсуляция обеспечивает сокрытие (во многих объектно-ориентированных языках программирования), но 
не является сокрытием**

Пример сокрытия в Python:  
Как было описано ранее, в Python существует соглашение по сокрытию. Одиночное подчеркивание в начале имени 
атрибута говорит о том, что переменная или метод не предназначен для использования вне методов класса, 
однако атрибут доступен по этому имени.

```Python
>>> class A:
...    def _private(self):
...        print("Это приватный метод!")
...        
>>> a = A()
>>> a._private()
Это приватный метод!
```
Двойное подчеркивание в начале имени атрибута даёт большую защиту: атрибут становится недоступным по 
этому имени.
```Python
>>> class B:
...     def __private(self):
...         print("Это приватный метод!")
...
>>> b = B()
>>> b.__private()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'B' object has no attribute '__private'
```
Однако полностью это не защищает, так как атрибут всё равно остаётся доступным под именем 
экземплярКласса._ИмяКласса__ИмяАтрибута:
```Python
>>> b._B__private()
Это приватный метод!
```
Все, что было указано выше называют уровнями доступа к данным:
1. Публичный (без подчеркиваний)
2. Защищенный (с одним подчеркиванием)
3. Приватный (с двумя подчеркиваниями)

### Наследование
Наследование - это механизм языка программирования, который позволяет описывать новый класс на основе 
существующего.

```Python
>>> class A:
...     def show_message(self):
...         print('message')
... 
>>> class B(A):
...     pass
... 
>>> b = B()
>>> b.show_message()
message
```
* Классы, которые наследуются от другого(-их) класса(-ов) называются подклассами или производными классами.
* Классы, из которых получены другие классы, называются суперклассами или базовыми классами.
* Производный класс порождает, наследует и расширяет базовый класс.

Здесь важно отметить, что вместо наследования можно использовать приемы агрегации и композиции:
* Агрегация подразумевает такой тип отношений между классами, в которых подкласс может существовать
независимо от родительской
```Python
class Engine:
    def __init__(self, capacity):
        self.capacity = capacity

class Car:
    def __init__(self, make, model):
        self.make = make
        self.model = model
        self.engine = Engine(2000)  # Агрегация - машина содержит двигатель с опр. объемом.
```
* Композиция подразумевает тип отношений между классами, в которых подкласс не может существовать 
без суперкласса. Если удалить родительский объект, то и все его части будут удалены.
```Python
class Wheel:
    def __init__(self, size):
        self.size = size

class Car:
    def __init__(self, model):
        self.model = model
        self.wheels = [Wheel(18) for _ in range(4)]  # Композиция - машина включает в себя четыре колеса
```
Важно понимать, что в Python реализовано множественное наследование - это возможность классу 
наследовать атрибуты и методы от нескольких родительских классов. Это означает, что класс может 
иметь более одной базовой реализации, и его потомки наследуют атрибуты и методы от всех этих 
родительских классов:
```Python
>>> class Parent1:
...     def first_parent_method(self):
...         ...
... 
>>> class Parent2:
...     def second_parent_method(self):
...         ...
... 
>>> class Child(Parent1, Parent2):
...     ...
... 
>>> print([method for method in dir(Child) if not method.startswith('_')])
['first_parent_method', 'second_parent_method']
```
Python использует алгоритм **MRO** для определения порядка, в котором наследуемые методы вызываются в 
случае множественного наследования. Этот порядок определяется с учетом иерархии классов и порядка 
их перечисления в скобках при создании класса.

```Python
class A:
    def method(self):
        print("Method in class A")

class B(A):
    def method(self):
        print("Method in class B")

class C(A):
    def method(self):
        print("Method in class C")

class D(B, C):
    pass

d = D()
d.method()

# Вывод: Method in class B
```
В этом примере MRO для класса D определяется как D -> B -> C -> A. Поэтому вызов d.method() будет 
вызывать метод из класса B, потому что D унаследовал от B первым.

Стоит отметить, что в версиях Python 2.x сталкивались с проблемой алмаза (diamond problem) из-за 
особенностей множественного наследования. В Python 2.x порядок методов в цепи наследования определялся 
простым линейным порядком, что могло привести к неоднозначностям и ошибкам, когда класс наследовал 
от нескольких классов, которые имели общего предка.

```Python
class A:
    def method(self):
        print("Method in class A")

class B(A):
    pass

class C(A):
    def method(self):
        print("Method in class C")

class D(B, C):
    pass

d = D()
d.method()
```
В Python 2.x при вызове d.method(), интерпретатор использовал линейный порядок наследования и 
выбирал метод из класса B, который был указан первым в списке базовых классов. Это могло привести 
к неожиданному поведению, так как метод из класса C был проигнорирован. То есть в примере бы вывелось
сообщение "Method in class A"

В Python 3.x введен алгоритм C3 Linearization (C3 MRO), который разрешает проблему алмаза более 
предсказуемо и устраняет неоднозначности, делая выбор метода более логичным и предсказуемым.

Сам процесс наследования в Python происходит следующим образом:
```
Марк Лутц "Изучаем Python"
Формально наследование вводит в действие две разных, но похожих процедуры поиска, и основано на MRO 
(Method Resolution Order — порядок распознавания методов).

Поскольку __bases__ (В Python, каждый класс имеет атрибуты __bases__ и __mro__. 
__bases__ содержит кортеж базовых классов, от которых класс наследует, и __mro__ представляет 
порядок распознавания методов (Method Resolution Order) для класса. Этот порядок определяет, 
в какой последовательности происходит поиск методов в цепи наследования.)
применяется для создания упорядочения __mro__ во время создания классов, а 
__mro__ класса включает самого себя, обобщение из предыдущего раздела будет таким же, как 
приведенное далее начальное определение алгоритма наследования нового стиля Python.

Для поиска явного имени атрибута выполнить описанные ниже шаги.
1. Начиная с экземпляра I, провести поиск в экземпляре, затем в его классе и далее
во всех суперклассах класса, используя:
а) словарь __diсt__ экземпляра I;
б) словари __diсt__ всех классов в __mro__ , найденном в __class__ экземпляра I, слева направо.

2. Начиная с класса С, провести поиск в классе, затем во всех его суперклассах и далее в его дереве 
метаклассов, используя:
а) словари __diсt__ всех классов в __mro__ , найденном в самом классе С, слева направо;
б) словари __diсt__ всех метаклассов в __mro__ , найденном в __class__ класса С, слева направо.

3. В шагах 1 и 2 предоставить приоритет дескрипторам данных, которые найдены в источниках в пункте б) 
(см. далее).

4. Для встроенных имен в шагах 1 и 2 пропустить пункт а) и начать поиск с пункта б) (см. далее).
Первые два шага выполняются только для обычного явного извлечения атрибутов.
Предусмотрены исключения для встроенных имен и дескрипторов, которые вскоре будут
прояснены. Вдобавок, как объяснялось в главе 38, для отсутствующих или всех имен
может также применяться метод __getattr__ или __getattribute__ .

Большинству программистов нужно знать лишь первое из этих правил и возможно первый шаг второго, 
которые вместе соответствуют наследованию классических классов Python 2.Х. Для метаклассов добавлен 
дополнительный шаг (2б), но по существу он такой же, как остальные — безусловно, довольно тонкая 
равнозначность, но метаклассы не настолько новы, как может показаться. Фактически они — всего лишь 
один компонент более крупной модели.
```
То есть исходя из цитаты из книги Марка Лутца наследование происходит следующим образом:  

Порядок поиска атрибутов (включая методы) происходит следующим образом:
* Сначала поиск начинается в экземпляре (объекте) класса.
* Затем поиск происходит в классе этого экземпляра.
* Далее происходит поиск во всех суперклассах класса (и их родительских классах) в порядке, 
определенном в `__mro__`.
* Приоритет даётся дескрипторам данных (data descriptors), если они найдены в пункте "б)".

Для встроенных (built-in) имен (например, len, str, list, и т. д.) поиск атрибутов пропускает 
шаг "а)" и начинается с шага "б)".

Для метаклассов добавляется дополнительный шаг в поиске атрибутов. Этот шаг подразумевает поиск в 
словарях `__dict__` всех классов в `__mro__`, а также в словарях `__dict__` всех метаклассов в `__mro__`.

### Полиморфизм

Выделяют три типа полиморфизма:
* Специальный полиморфизм (Ad Hoc полиморфизм) - заключается в перегрузке методов, то есть в создании
одинаковых методов с разными принимаемыми на входе типами аргументов. Очевидно, что в Python данный
вид полиморфизма не используется из-за динамической природы языка.
* Параметрический полиморфизм - этот вид полиморфизма связан с использованием обобщенных типов данных 
(generics). В языках программирования, поддерживающих обобщенное программирование, вы можете создавать 
классы и функции, которые работают с разными типами данных, не указывая конкретный тип во время 
написания кода. Это делает код более универсальным и повторно используемым. В Python параметрический 
полиморфизм реализуется с использованием дженериков в некоторых сторонних библиотеках, но не так 
часто, как в некоторых других языках, например JS.
* Полиморфизм подтипов - этот вид полиморфизма связан с использованием наследования и переопределением 
методов в классах. Подтип полиморфизма позволяет объектам разных классов предоставлять общий интерфейс 
(например, через наследование) и иметь разные реализации этого интерфейса. Это позволяет использовать 
объекты разных классов с одинаковым интерфейсом в общем контексте, что называется "полиморфизмом 
подтипов".









  